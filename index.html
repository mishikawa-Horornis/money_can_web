<!DOCTYPE html>
<!--
    Money Counter ©2018-2019 Masatoshi Ishikawa.
    2019.02.27 Release Version 2.4.092
-->
<html lang="ja">
<head>
    <meta charset="utf-8">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="./fontawesome-free-web/css/all.min.css">
    <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="css/main.css" rel="stylesheet" type="text/css">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="This is the one of the money counter application.">
    <title>まねかん by Horornis.com</title>

    <!-- Disable tap highlight on IE -->
    <meta name="msapplication-tap-highlight" content="no">

    <!-- Web Application Manifest -->
    <link rel="manifest" href="./manifest.json">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="まねかん">
    <link rel="icon" sizes="512x512" href="images/icon-192x192.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="まねかん">
    <link rel="apple-touch-icon" href="./images/apple-touch-icon.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/icon-512x512.png">
    <meta name="msapplication-TileColor" content="olivedrab">

    <!-- Color the status bar on mobile devices -->
    <meta name="theme-color" content="olivedrab">
    <!-- Vue.js Develop -->
    <script src="./js/jquery-3.3.1.min.js"></script>
    <script src="./js/popper.min.js"></script>
    <script src="./bootstrap/js/bootstrap.min.js"></script>
    <!-- script src="./fontawesome-free-web/js/all.min.js"></script-->
    <script src="./js/Sortable.min.js"></script>
    <script src="./js/store2.min.js"></script>
    <script src="./js/clipboard.min.js"></script>
    <script src="./js/vue.min.js"></script>
</head>
<body>
<!--script>
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./service-worker.js', {scope: 'https://horornis.com/mc/'})
            .then(function(reg) {
                // registration worked
                // console.log('Registration succeeded. Scope is ' + reg.scope);
            }).catch(function(error) {
            // registration failed
            // console.log('Registration failed with ' + error);
        });
    }
</script -->
<script>
    const RADIUS = 40;
    const MID_X = 50;
    const MID_Y = 50;
    const MIN_RADIANS = 4 * Math.PI / 3;
    const MAX_RADIANS = -Math.PI / 3;

    // map a value (x) from one range (in min/max) onto another (out min/max)
    const mapRange = (x, inMin, inMax, outMin, outMax) => {
        return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    };
    Vue.component('knob-control', {
        data() {
            return {}
        },
        template: '<div class="knob-control" :style="{ height: size-5 + \'px\' }">\n' +
            '   <svg :width="size" :height="size" viewBox="0 0 100 100"\n' +
            '       @click="onClick"\n' +
            '       @mousedown="onMouseDown"\n' +
            '       @mouseup="onMouseUp"\n' +
            '       @touchstart="onTouchStart"\n' +
            '       @touchend="onTouchEnd">\n' +
            '   <path\n' +
            '       :d="rangePath"\n' +
            '       :stroke-width="strokeWidth"\n' +
            '       :stroke="secondaryColor"\n' +
            '       class="knob-control__range">\n' +
            '   </path>\n' +
            '   <path\n' +
            '   v-if="showValue"\n' +
            '       :d="valuePath"\n' +
            '       :stroke-width="strokeWidth"\n' +
            '       :stroke="primaryColor"\n' +
            '       class="knob-control__value">\n' +
            '   </path>\n' +
            '   <text\n' +
            '       v-if="showValue"\n' +
            '       :x="50"\n' +
            '       :y="57"\n' +
            '       text-anchor="middle"\n' +
            '       :fill="textColor"\n' +
            '       class="knob-control__text-display">\n' +
            '           {{valueDisplay}}\n' +
            '   </text>\n' +
            '   </svg>\n' +
            '</div>\n',
        props: {
            'value': {
                type: Number,
                required: true
            },
            'max': {
                type: Number,
                default: 100
            },
            'min': {
                type: Number,
                default: 0
            },
            'stepSize': {
                type: Number,
                default: 1
            },
            'disabled': {
                type: Boolean,
                default: false
            },
            'size': {
                type: Number,
                default: 100
            },
            'primaryColor': {
                type: String,
                default: '#409eff'
            },
            'secondaryColor': {
                type: String,
                default: '#dcdfe6'
            },
            'textColor': {
                type: String,
                default: '#000000'
            },
            'strokeWidth': {
                type: Number,
                default: 17
            },
            'valueDisplayFunction': {
                type: Function,
                default: (v) => v
            },
        },
        computed: {
            rangePath() {
                return `M ${this.minX} ${this.minY} A ${RADIUS} ${RADIUS} 0 1 1 ${this.maxX} ${this.maxY}`;
            },
            valuePath() {
                return `M ${this.zeroX} ${this.zeroY} A ${RADIUS} ${RADIUS} 0 ${this.largeArc} ${this.sweep} ${this.valueX} ${this.valueY}`;
            },
            showValue() {
                return (this.value >= this.min && this.value <= this.max) && !this.disabled;
            },
            zeroRadians() {
                /* this weird little bit of logic below is to handle the fact that usually we
                    want the value arc to start drawing from the 'zero' point, but, in the case
                    that the minimum and maximum values are both above zero, we set the 'zero point'
                    at the supplied minimum, so the value arc renders as the user would expect */
                if (this.min > 0 && this.max > 0)
                    return mapRange(this.min, this.min, this.max, MIN_RADIANS, MAX_RADIANS);
                else
                    return mapRange(0, this.min, this.max, MIN_RADIANS, MAX_RADIANS);
            },
            valueRadians() {
                return mapRange(this.value, this.min, this.max, MIN_RADIANS, MAX_RADIANS);
            },
            minX() {
                return MID_X + Math.cos(MIN_RADIANS) * RADIUS;
            },
            minY() {
                return MID_Y - Math.sin(MIN_RADIANS) * RADIUS;
            },
            maxX() {
                return MID_X + Math.cos(MAX_RADIANS) * RADIUS;
            },
            maxY() {
                return MID_Y - Math.sin(MAX_RADIANS) * RADIUS;
            },
            zeroX() {
                return MID_X + Math.cos(this.zeroRadians) * RADIUS;
            },
            zeroY() {
                return MID_Y - Math.sin(this.zeroRadians) * RADIUS;
            },
            valueX() {
                return MID_X + Math.cos(this.valueRadians) * RADIUS;
            },
            valueY() {
                return MID_Y - Math.sin(this.valueRadians) * RADIUS;
            },
            largeArc() {
                return Math.abs(this.zeroRadians - this.valueRadians) < Math.PI ? 0 : 1;
            },
            sweep() {
                return this.valueRadians > this.zeroRadians ? 0 : 1;
            },
            valueDisplay() {
                return this.valueDisplayFunction(this.value);
            },
        },
        methods: {
            updatePosition(offsetX, offsetY) {
                const dx = offsetX - this.size / 2;
                const dy = this.size / 2 - offsetY;
                const angle = Math.atan2(dy, dx);
                let v;
                /* bit of weird looking logic to map the angles returned by Math.atan2() onto
                    our own unconventional coordinate system */
                const start = -Math.PI / 2 - Math.PI / 6;
                if (angle > MAX_RADIANS) {
                    v = mapRange(angle, MIN_RADIANS, MAX_RADIANS, this.min, this.max);
                } else if (angle < start) {
                    v = mapRange(angle + 2 * Math.PI, MIN_RADIANS, MAX_RADIANS, this.min, this.max);
                } else {
                    return;
                }
                this.$emit('input', Math.round((v - this.min) / this.stepSize) * this.stepSize + this.min);
            },
            onClick(e) {
                if (!this.disabled) {
                    this.updatePosition(e.offsetX, e.offsetY);
                }
            },
            onMouseDown(e) {
                if (!this.disabled) {
                    e.preventDefault();
                    window.addEventListener('mousemove', this.onMouseMove);
                    window.addEventListener('mouseup', this.onMouseUp);
                }
            },
            onMouseUp(e) {
                if (!this.disabled) {
                    e.preventDefault();
                    window.removeEventListener('mousemove', this.onMouseMove);
                    window.removeEventListener('mouseup', this.onMouseUp);
                }
            },
            onTouchStart(e) {
                if (!this.disabled) {
                    e.preventDefault();
                    window.addEventListener('touchmove', this.onTouchMove);
                    window.addEventListener('touchend', this.onTouchEnd);
                }
            },
            onTouchEnd(e) {
                if (!this.disabled) {
                    e.preventDefault();
                    window.removeEventListener('touchmove', this.onTouchMove);
                    window.removeEventListener('touchend', this.onTouchEnd);
                }
            },
            onMouseMove(e) {
                if (!this.disabled) {
                    e.preventDefault();
                    this.updatePosition(e.offsetX, e.offsetY);
                }
            },
            onTouchMove(e) {
                if (!this.disabled && e.touches.length == 1) {
                    const boundingClientRect = this.$el.getBoundingClientRect();
                    const touch = e.targetTouches.item(0);
                    const offsetX = touch.clientX - boundingClientRect.left;
                    const offsetY = touch.clientY - boundingClientRect.top;
                    this.updatePosition(offsetX, offsetY);
                }
            },
        },

    });
</script>
<style>
    .knob-control__range {
        fill: none;
        transition: stroke .1s ease-in;
    }
    .knob-control__value {
        fill: none;
    }
    .knob-control__text-display {
        font-size: 1.3rem;
        text-align: center;
    }
</style>
<div class="wrap">
    <div class="content" id="app">
        <div class="dummy"></div>
        <div class="tbl">
            <div v-for="(item, index) in items" class="row" :id="item.type" :alt="item.callName" v-show="item.visible" >
                <div class="r2nd">
                    <div alt="hidden" @click="dohide(index)" class="del col-sm-1"><i class="fas fa-eraser"></i></div>
                    <div alt="handle" class="handle"><i class="fas fa-arrows-alt"></i></div>
                    <div alt="小計" class="sum" width="200px" align="right">&yen;{{ subtotalMoney[index].toLocaleString() }}</div>
                </div>
                <div class="r1st">
                    <input class="cst" type="hidden" :value="item.unit" width="1px" height="1px"/>
                    <img :alt="item.callName + 'の枚数'" class="image m-0 p-0 coin_picture" :src="'images/coin-' + item.unit + '.png'" width="300px"/>
                    <knob-control class="dial" primaryColor="darkgreen" secondaryColor="gray" :min="0" :max="50" :size="170" v-model="item.number"></knob-control>
                </div>
            </div>
        </div>
        <div class="ft">
        </div>
        <div class="fixed-bottom border-white border-top-2">
            <div class="ft_txt">
                © 2019 Horornis.com All Rights Reserved.
            </div>
        </div>
        <!-- As a heading -->
        <div class="top_bar">
        <span class="fixed-top">
            <nav class="navbar navbar-light bg-white border-bottom-4 border-success Regular shadow p-0 m-0">
                <img alt="まねかん Powered by Horornis.com." src="images/site-logo.png" class="navbar-brand" width="300px"/>
                <span class="right">
                    <button class="btn btn-outline-primary m-0 p-0 foo" :data-clipboard-text="totalValue" width="300px"><span id="sumtitle"> 合計 </span><span id="sumresult">&yen;{{ totalMoney }} </span><span id="sumconst">&#x1F4CB;</span></button>
                    <button class="btn btn-outline-danger allClear m-0" @click="doclear"><strong> C </strong></button>
                </span>
                <div class="bg-white header3">
                    <div class="hidden_list">
                        <div class="hidden_menu">
                            非表示：
                        </div>
                        <div v-for="(item, index) in items" class="btn btn-outline-dark btn-warning .text-dark type_item p-1" v-show="!item.visible" @click="doshow(index)" >
                            {{ item.callName }}
                        </div>
                    </div>
                </div>
            </nav>
        </span>
        </div>
    </div>
</div>
<script>
    function initialState() {
        const old_cookiehead = '.Horornis-moneycounter-v2_4_91-';
        const data = {
            cookiehead: '.Horornis-money_can-v3_0_1',
            items: [
                {id: 0, order: 0, type: 's1', callName: '1円', unit: 1, number: 0, visible: true},
                {id: 1, order: 1, type: 's5', callName: '5円', unit: 5, number: 0, visible: true},
                {id: 2, order: 2, type: 's10', callName: '10円', unit: 10, number: 0, visible: true},
                {id: 3, order: 3, type: 's50', callName: '50円', unit: 50, number: 0, visible: true},
                {id: 4, order: 4, type: 's100', callName: '100円', unit: 100, number: 0, visible: true},
                {id: 5, order: 5, type: 's500', callName: '500円', unit: 500, number: 0, visible: true},
                {id: 6, order: 6, type: 's1000', callName: '千円', unit: 1000, number: 0, visible: false},
                {id: 7, order: 7, type: 's2000', callName: '弐千円', unit: 2000, number: 0, visible: false},
                {id: 8, order: 8, type: 's5000', callName: '五千円', unit: 5000, number: 0, visible: false},
                {id: 9, order: 9, type: 's10000', callName: '壱万円', unit: 10000, number: 0, visible: false}
            ]
        };
        let ret = {
            cookiehead: '.Horornis-money_can-v3_0_1',
            items: []
        };
        if (store.has(data.cookiehead)) ret.items = store.get(data.cookiehead);
        // console.log(ret.items);
        if (ret.items.length === 10) {
            return ret;
        }
        for (let i = 0; i < data.length; i++) {
            if (store.has(old_cookiehead + data.items[i].type)) {
                data.items[i].number = store.get(old_cookiehead + data.items[i].type).count;
                data.items[i].visible = !(store.get(old_cookiehead + data.items[i].type).hide);
                store.delete(old_cookiehead + data.items[i].type);
            }
        }
        return data;
    }
    const app = new Vue({
        el: '#app',
        data () {
            return initialState();
        },
        computed: {
            totalMoney: function () {
                let total = 0;
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i].visible) {
                        total += this.items[i].unit * this.items[i].number;
                    }
                }
                store.set(this.cookiehead,this.items);
                // console.log(this.cookiehead,JSON.stringify(this.items));
                return Number(total).toLocaleString();
            },
            totalValue: function () {
                let total = 0;
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i].visible) {
                        total += this.items[i].unit * this.items[i].number;
                    }
                }
                return total;
            },
            subtotalMoney: function () {
                let ret = [];
                for (let i = 0; i < this.items.length; i++) {
                    ret.push(Number(this.items[i].unit * this.items[i].number).toLocaleString());
                }
                return ret;
            }
        },
        methods: {
            dohide: function (i) {
                this.items[i].number = 0;
                this.items[i].visible = false;
            },
            doshow: function (i) {
                this.items[i].visible = true;
            },
            doclear: function () {
                for (let i = 0; i < this.items.length; i++) {
                    this.items[i].number = 0;
                }
            },
        }
    });

    let clipboard = new ClipboardJS('.foo');
    clipboard.on('success', function (e) {
        alert('クリップボードへコピーしました。');
    });
    clipboard.on('error', function (e) {
        alert('クリップボードへのコピーに失敗しました。');
    });
    $(function () {
        Sortable.create($('.tbl')[0], {
            handle: '.handle',
            animation: 150  // ミリ秒で指定
        });
    });
</script>
</body>
</html>
